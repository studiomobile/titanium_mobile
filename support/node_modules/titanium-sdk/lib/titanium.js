/**
 * Titanium SDK Library for Node.js
 * Copyright (c) 2012 by Appcelerator, Inc. All Rights Reserved.
 * Please see the LICENSE file for information about licensing.
 */
var fs = require('fs'),
	path = require('path'),
	async = require('async'),
	appc = require('node-appc'),
	i18n = appc.i18n(__dirname),
	__ = i18n.__,
	__n = i18n.__n,
	spawn = require('child_process').spawn,
	afs = appc.fs,
	version = appc.version,
	manifest = appc.pkginfo.manifest(module),
	platformAliases = {
		// add additional aliases here for new platforms
		'ipad': 'iphone',
		'ios': 'iphone'
	};

exports.i18n = require('./i18n');
exports.jss = require('./jss');
exports.tiappxml = require('./tiappxml');
exports.legacy = require('./legacy');

exports.manifest = manifest;
exports.targetPlatforms = manifest.platforms.map(function (p) {
	return p == 'iphone' ? 'ios' : p;
}).sort();
exports.availablePlatforms = (manifest.platforms || []).sort();
exports.availablePlatformsNames = function (platforms) {
	Object.keys(platformAliases).forEach(function (alias) {
		if (platforms.indexOf(platformAliases[alias]) != -1) {
			platforms.push(alias);
		}
	});
	return platforms.sort();
}(manifest.platforms || []);

exports.commonOptions = function (logger, config) {
	return {
		sdk: {
			abbr: 's',
			desc: __('Titanium SDK version to use to bootstrap SDK-level commands and parse the tiapp.xml; actual Titanium SDK used determined by %s in the tiapp.xml', '<sdk-version>'.cyan)
		},
		'log-level': {
			callback: function (value) {
				logger.levels.hasOwnProperty(value) && logger.setLevel(value);
			},
			desc: __('minimum logging level'),
			default: config.cli.logLevel || 'info',
			hint: __('level'),
			values: logger.getLevels()
		}
	};
};

exports.platformOptions = function (logger, config, cli, commandName, finished) {
	var result = {};
	
	if (!commandName) {
		finished(result);
		return;
	}
	
	function set(obj, title, platform) {
		// add the platform and title to the options and flags
		['options', 'flags'].forEach(function (type) {
			if (obj[type]) {
				result[platform] || (result[platform] = {
					platform: platform,
					title: title || platform
				});
				result[platform][type] = obj[type];
			}
		});
	}
	
	// for each platform, fetch their specific flags/options
	async.parallel(manifest.platforms.map(function (platform) {
		return function (callback) {
			var platformDir = path.join(path.dirname(module.filename), '..', '..', '..', platform),
				platformCommand = path.join(platformDir, 'cli', 'commands', '_' + commandName + '.js'),
				command,
				conf,
				title;
			
			if (!afs.exists(platformCommand)) return callback();
			
			command = require(platformCommand);
			if (!command || !command.config) return callback();
			
			// try to get the platform specific configuration
			conf = command.config(logger, config, cli);
			
			try {
				// try to read a title from the platform's package.json
				title = JSON.parse(fs.readFileSync(path.join(platformDir, 'package.json'))).title;
			} catch (e) {}
			
			if (typeof conf == 'function') {
				// async callback
				conf(function (obj) {
					set(obj, title, platform);
					callback();
				});
				return;
			}

			set(conf, title, platform);
			callback();
		};
	}), function () {
		finished(result);
	});
};

exports.validateProjectDir = function(logger, cli, argv, name) {
	var dir = argv[name] || (process.env.SOURCE_ROOT ? path.join(process.env.SOURCE_ROOT, '..', '..') : '.'),
		projectDir = argv[name] = appc.fs.resolvePath(dir);

	if (!appc.fs.exists(projectDir)) {
		logger.banner();
		logger.error(__('Project directory does not exist') + '\n');
		process.exit(1);
	}
	
	var tiapp = path.join(projectDir, 'tiapp.xml');
	while (!appc.fs.exists(tiapp) && tiapp.split(path.sep).length > 2) {
		projectDir = argv[name] = path.dirname(projectDir);
		tiapp = path.join(projectDir, 'tiapp.xml');
	}
	
	if (tiapp.split(path.sep).length == 2) {
		logger.banner();
		logger.error(__('Invalid project directory "%s"', dir) + '\n');
		dir == '.' && logger.log(__("Use the %s property to specify the project's directory", '--project-dir'.cyan) + '\n');
		process.exit(1);
	}
	
	cli.tiapp = new exports.tiappxml(path.join(projectDir, 'tiapp.xml'));
};

exports.loadPlugins = function (logger, cli, config, projectDir) {
	// find all hooks for active plugins
	appc.tiplugin.find(cli.tiapp.plugins, projectDir, config, logger, function (plugins) {
		if (plugins.missing.length) {
			logger.error(__('Could not find all required Titanium plugins:'))
			plugins.missing.forEach(function (m) {
				logger.error('   id: ' + m.id + '\t version: ' + m.version);
			});
			logger.log();
			process.exit(1);
		}
		
		if (plugins.found.length) {
			plugins.found.forEach(function (plugin) {
				// we don't support plugins that have both a plugin.py and new .js files
				plugin.legacy || cli.scanHooks(afs.resolvePath(plugin.pluginPath, 'hooks'));
			});
		} else {
			logger.debug(__('No project level plugins to load'));
		}
	});
	
	if (cli.hooks.loadedFilenames.length) {
		// display all hooks for debugging
		logger.debug(__('Loaded plugin hooks:'));
		cli.hooks.loadedFilenames.forEach(function (f) {
			logger.debug(f.cyan);
		});
	}
	
	if (cli.hooks.incompatibleFilenames.length) {
		// display all hooks for debugging
		logger.debug(__('Incompatible plugin hooks:'));
		cli.hooks.incompatibleFilenames.forEach(function (f) {
			logger.debug(f.cyan);
		});
	}
};

exports.validateCorrectSDK = function (logger, config, cli, commandName) {
	// tiapp.xml should exist by the time we get here
	var sdk = cli.tiapp['sdk-version'];
	if (!sdk || version.eq(sdk, manifest.version)) return true;
	
	// check the project's preferred sdk is even installed
	if (sdk == '__global__' || !cli.env.sdks[sdk]) {
		logger.banner();
		logger.error(__("Unable to compile project because the 'sdk-version' in the tiapp.xml is not installed") + '\n');
		logger.log(__("The project's %s is currently set to %s, which is not installed.", 'sdk-version'.cyan, sdk.cyan) + '\n');
		logger.log(__("Update the %s in the tiapp.xml to one of the installed Titaniums SDKs:", 'sdk-version'.cyan));
		Object.keys(cli.env.sdks).sort().forEach(function (ver) {
			if (ver != '__global__') {
				logger.log('    ' + ver.cyan);
			}
		});
		logger.log(__("or run '%s' to download and install Titanium SDK %s", ('titanium sdk install ' + sdk).cyan, sdk) + '\n');
		process.exit(1);
	}
	
	var args = cli.argv.$_,
		p = args.indexOf('--sdk'),
		platform = exports.resolvePlatform(cli.argv.platform),
		cmd = [],
		emulatorCmd = [],
		cmdRoot,
		hideBanner = false;
	
	if (p != -1) {
		args.splice(p, 2);
	}
	
	if (version.lt(sdk, '2.2.0')) { // technically, there is no 2.2, it was released as 3.0
		cmdRoot = 'python';
		exports.legacy.constructLegacyCommand(cli, cli.tiapp, platform, cmd, emulatorCmd);
	} else {
		cmdRoot = 'node';
		cmd = [cli.argv.$0.split(' ').slice(1), commandName, '--sdk', sdk];
		hideBanner = true;
		
		function copyArgs(ctx) {
			if (ctx.flags) {
				Object.keys(ctx.flags).forEach(function (f) {
					if (cli.argv.hasOwnProperty(f)) {
						cmd.push('--' + (!!cli.argv[f] ? '' : 'no-') + f);
					}
				});
			}
			
			if (ctx.options) {
				Object.keys(ctx.options).forEach(function (o) {
					if (o != 'sdk' && cli.argv.hasOwnProperty(o)) {
						cmd.push('--' + o);
						cmd.push(cli.argv[o]);
					}
				});
			}
		}
		
		try {
			var ctx = cli.cmds[commandName][manifest.version].__global__;
			copyArgs(ctx);
			ctx.platforms && ctx.platforms[platform] && copyArgs(ctx.platforms[platform]);
		} catch (ex) {}
	}
	
	// fork or die
	if (config.cli.failOnWrongSDK) {
		logger.banner();
		logger.error(__('Unable to compile a %s project with Titanium SDK %s', sdk, manifest.version) + '\n');
		logger.log(__("Run '%s' to build using the correct Titanium SDK or update the %s in the tiapp.xml to the current Titaniums SDK: %s",
			(cmdRoot + cmd.join(' ')).cyan, 'sdk-version'.cyan, manifest.version.cyan) + '\n');
		process.exit(1);
	}
	
	if (emulatorCmd.length > 0) {
		// console.log('Forking correct SDK command: ' + ( cmdRoot + ' ' +  emulatorCmd.join(' ') ).cyan + '\n');
		spawn(cmdRoot, emulatorCmd,{});
	}
	
	logger.info(__('tiapp.xml <sdk-version> set to %s, but current Titanium SDK set to %s', sdk.cyan, manifest.version.cyan));
	logger.info(__('Forking correct SDK command: %s', (cmdRoot + ' ' +  cmd.join(' ')).cyan));
	hideBanner && cmd.push('--no-banner');
	spawn(cmdRoot, cmd, {
		stdio: 'inherit'
	});
};

exports.validatePlatformOptions = function (logger, config, cli, commandName) {
	var platform = exports.resolvePlatform(cli.argv.platform),
		platformCommand = path.join(path.dirname(module.filename), '..', '..', '..', manifest.platforms[manifest.platforms.indexOf(platform)], 'cli', 'commands', '_' + commandName + '.js');
	
	if (afs.exists(platformCommand)) {
		var command = require(platformCommand),
			result = command && command.validate ? command.validate(logger, config, cli) : null;
		if (result === false) {
			return false;
		}
	}
};

exports.scrubPlatforms = function (platforms) {
	var r = {
		scrubbed: [], // distinct list of un-aliased platforms
		bad: []
	};
	
	platforms.toLowerCase().split(',').forEach(function (p) {
		var a = platformAliases[p] || p;
		if (a) {
			if (manifest.platforms.indexOf(a) == -1) {
				r.bad.push(p);
			} else if (r.scrubbed.indexOf(a) == -1) {
				r.scrubbed.push(a);
			}
		}
	});
	
	return r;
};

exports.resolvePlatform = function (platform) {
	return platformAliases[platform] || platform;
};

exports.filterPlatforms = function (platform) {
	platform = platformAliases[platform] || platform;
	return exports.availablePlatformsNames.filter(function (name) {
		return name != platform;
	});
};

exports.validatePlatform = function (logger, argv, name) {
	var platform = name ? argv[name] : argv,
		p = argv[name] = platformAliases[platform] || platform;
	if (!p || manifest.platforms.indexOf(p) == -1) {
		logger.banner();
		logger.error(__('Invalid platform "%s"', platform) + '\n');
		appc.string.suggest(platform, exports.targetPlatforms, logger.log);
		logger.log(__('Available platforms for SDK version %s:', manifest.version));
		exports.targetPlatforms.forEach(function (p) {
			logger.log('    ' + p.cyan);
		});
		logger.log();
		process.exit(1);
	}
};

exports.validatePlatforms = function (logger, platforms) {
	platforms.forEach(function (p) {
		exports.validatePlatform(logger, p);
	});
	return platforms;
};