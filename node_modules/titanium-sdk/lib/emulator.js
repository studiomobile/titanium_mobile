/**
 * @overview
 * Library for controlling an Android Emulator.
 *
 * @module lib/emulator
 *
 * @copyright
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 *
 * @license
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

var appc = require('node-appc'),
	__ = appc.i18n(__dirname).__,
	ADB = require('./adb'),
	async = require('async'),
	events = require('events'),
	fs = require('fs'),
	path = require('path'),
	util = require('util');

module.exports = EmulatorManager;

/**
 * Creates an Emulator instace.
 * @class
 * @extends EventEmitter
 * @classdesc Simple object that contains the avd settings and exposes event
 * methods.
 * @constructor
 */
function Emulator() {}
util.inherits(EmulatorManager.Emulator = Emulator, events.EventEmitter);

/**
 * Creates an EmulatorManager instance.
 * @class
 * @classdesc Manages emulator implementations and responsible for launching and
 * killing emulators.
 * @constructor
 * @param {Object} config - The CLI config object
 */
function EmulatorManager(config) {
	this.config = config;
}

/**
 * Loads emulator implementation modules and detects all available emulators.
 * @param {Object} [opts] - Detection options
 * @param {String} [opts.type] - The type of emulator to load (avd, genymotion); defaults to all
 * @param {Function} callback - A function to call when the detection has completed
 */
EmulatorManager.prototype.detect = function detect(opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	var files = opts && opts.type ? [ opts.type + '.js' ] : fs.readdirSync(path.join(__dirname, 'emulators')),
		re = /\.js$/,
		config = this.config;

	async.parallel(files.map(function (filename) {
		return function (next) {
			var file = path.join(__dirname, 'emulators', filename);
			if (re.test(filename) && fs.existsSync(file)) {
				var module = require(file);
				if (typeof module.detect == 'function') {
					module.detect(config, opts, next);
					return;
				}
			}
			next();
		};
	}), function (err, results) {
		if (err) {
			callback(err);
		} else {
			var emus = [];
			results.forEach(function (r) {
				r && Array.isArray(r.avds) && (emus = emus.concat(r.avds));
			});
			callback(null, emus);
		}
	});
};

/**
 * Detects if a specific Android emulator is running.
 * @param {String} name - The name of the emulator
 * @param {Object} [opts] - Detection options
 * @param {String} [opts.type] - The type of emulator to load (avd, genymotion); defaults to all
 * @param {Function} callback - A function to call when the detection has completed
 */
EmulatorManager.prototype.isRunning = function isRunning(name, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	this.detect(opts, function (err, emus) {
		if (err) return callback(err);

		var emu = emus.filter(function (e) {
			return e && e.name == name;
		}).shift();

		if (!emu) return callback(new Error(__('Invalid emulator "%s"', name)), null);

		// need to see if the emulator is running
		var adb = new ADB(this.config);
		adb.devices(function (err, devices) {
			if (err) return callback(err);

			// if there are no devices, then it can't possibly be running
			if (!devices.length) return callback(null, null);

			require(path.join(__dirname, 'emulators', emu.type + '.js')).isRunning(this.config, emu, devices, callback);
		}.bind(this));
	}.bind(this));
};

/**
 * Determines if the specified "device name" is an emulator or a device.
 * @param {String} device - The name of the device returned from 'adb devices'
 * @param {Object} [opts] - Detection options
 * @param {String} [opts.type] - The type of emulator to load (avd, genymotion); defaults to all
 * @param {Function} callback - A function to call when the detection has completed
 */
EmulatorManager.prototype.isEmulator = function isEmulator(device, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	var files = opts && opts.type ? [ opts.type + '.js' ] : fs.readdirSync(path.join(__dirname, 'emulators')),
		re = /\.js$/,
		config = this.config;

	async.parallel(files.map(function (filename) {
		return function (next) {
			var file = path.join(__dirname, 'emulators', filename);
			if (re.test(filename) && fs.existsSync(file)) {
				var module = require(file);
				if (typeof module.isEmulator == 'function') {
					module.isEmulator(config, device, next);
					return;
				}
			}
			next();
		};
	}), function (err, results) {
		if (err) {
			callback(new Error(__('Unable to find device "%s"', device)));
		} else {
			callback(null, results.filter(function (n) { return n; }).shift());
		}
	});
};

function checkedBooted(config, opts, emulator) {
	// we need to get the id of emulator
	var adb = new ADB(config),
		retryTimeout = 250, // if an adb call fails, how long before we retry
		bootTimeout = opts.bootTimeout || 60000, // 1 minute to boot before timeout
		// if a timeout is set and the emulator doesn't boot quick enough, fire the timeout event,
		// however if the timeout is zero, still listen for the timeout to kill the whilst loop above
		bootTimer = setTimeout(function () {
			bootTimeout && emulator.emit('timeout', { type: 'device', waited: bootTimeout });
			done = true;
		}, bootTimeout || 30000),
		sdcardTimeout = opts.sdcardTimeout || 60000, // 1 minute to boot before timeout
		sdcardTimer,
		done = false,
		deviceId,
		emu = emulator.emulator,
		emulib = require(path.join(__dirname, 'emulators', emu.type + '.js')),
		devicesCache;

	// keep polling the devices until the emulator we want is running
	async.whilst(
		function () { return !done; },
		function (cb) {
			if (!deviceId) {
				adb.devices(function (err, devices) {
					if (err || !devices.length) {
						setTimeout(cb, retryTimeout);
						return;
					}
					emulib.isRunning(config, emu, devices, function (err, running) {
						if (err) {
							// TODO: this could be bad... maybe we should emit an error event?
							done = true;
							cb();
						} else if (!running) {
							// try again
							setTimeout(cb, retryTimeout);
						} else {
							// running!
							appc.util.mix(emulator, running);
							deviceId = running.id;
							cb();
						}
					});
				});
			} else {
				// emulator is running, now shell into it and check if it has booted
				adb.shell(deviceId, 'getprop init.svc.bootanim', function (err, output) {
					if (!err && output.toString().split('\n').shift().trim() == 'stopped') {
						clearTimeout(bootTimer);
						done = true;

						// requery the devices since the device state has changed
						adb.devices(function (err, devices) {
							emulib.isRunning(config, emu, devices.filter(function (d) { return d.id = emulator.id; }), function (err, running) {
								if (!err && running) {
									appc.util.mix(emulator, running);
								}
								emulator.emit('booted', emulator);
								cb();
							});
						});
						return;
					}
					setTimeout(cb, retryTimeout);
				});
			}
		}.bind(this),
		function () {} // do nothing
	);

	emulator.on('booted', function () {
		var done = false;

		opts.logger && opts.logger.info(__('Device is booted'));

		if (!opts.checkMounts || !emu.sdcard) {
			// nothing to do, fire ready event
			opts.logger && opts.logger.info(__('SD card not required, skipping mount check'));
			emulator.emit('ready', emulator);
			return;
		}

		opts.logger && opts.logger.info(__('Checking if SD card is mounted'));

		// keep polling /sdcard until it's mounted
		async.whilst(
			function () { return !done; },

			function (cb) {
				// emulator is running, now shell into it and check if it has booted
				adb.shell(deviceId, 'cd /sdcard && echo "SDCARD READY"', function (err, output) {
					if (!err && output.toString().split('\n').shift().trim() == 'SDCARD READY') {
						done = true;
						cb();
					} else {
						setTimeout(cb, retryTimeout);
					}
				});
			}.bind(this),

			function () {
				var mounted = false,
					mountPoints = [ '/sdcard', '/mnt/sdcard' ];

				adb.shell(deviceId, 'ls -l /sdcard', function (err, output) {
					if (!err) {
						var m = output.toString().trim().split('\n').shift().trim().match(/\-\> (\S+)/);
						if (m && mountPoints.indexOf(m[1]) == -1) {
							mountPoints.unshift(m[1]);
						}
					}

					opts.logger && opts.logger.debug(__('Checking mount points: %s', mountPoints.join(', ').cyan));

					// wait for the sd card to be mounted
					async.whilst(
						function () { return !mounted; },

						function (cb) {
							adb.shell(deviceId, 'mount', function (err, output) {
								if (!err && output.toString().trim().split('\n').some(function (line) {
									var parts = line.trim().split(' ');
									return parts.length > 1 && mountPoints.indexOf(parts[1]) != -1;
								})) {
									mounted = true;
									clearTimeout(sdcardTimer);
									opts.logger && opts.logger.debug(__('SD card is mounted'));
									cb();
								} else {
									setTimeout(cb, retryTimeout);
								}
							});
						},

						function () {
							// requery the devices since device state may have changed
							adb.devices(function (err, devices) {
								emulib.isRunning(config, emu, devices.filter(function (d) { return d.id = emulator.id; }), function (err, running) {
									if (!err && running) {
										appc.util.mix(emulator, running);
									}
									emulator.emit('ready', emulator);
								});
							});
						}
					);
				});
			}
		);

		sdcardTimer = setTimeout(function () {
			sdcardTimeout && emulator.emit('timeout', { type: 'sdcard', waited: sdcardTimeout });
			done = true;
		}, sdcardTimeout || 30000);
	});
}

/**
 * Starts the specified emulator, if not already running.
 * @param {String} name - The name of the emulator
 * @param {Object} [opts] - Options for detection and launching the emulator
 * @param {Function} callback - A function to call when the emulator as launched
 */
EmulatorManager.prototype.start = function start(name, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	this.isRunning(name, opts, function (err, running) {
		if (err) {
			// something went boom
			return callback(err);
		}

		if (running) {
			// already running
			var emulator = new Emulator;
			appc.util.mix(emulator, running);
			opts.logger && opts.logger.info(__('Emulator already running'));
			checkedBooted(this.config, opts, emulator);
			callback(null, emulator);
			return;
		}

		// not running, start the emulator
		this.detect(opts, function (err, emus) {
			if (err) {
				return callback(err);
			}

			var emu = emus.filter(function (e) {
				return e && e.name == name;
			}).shift();

			// this should never happen because it would have happened already thanks to isRunning()
			if (!emu) return callback(new Error(__('Invalid emulator "%s"', name)), null);

			var emulib = require(path.join(__dirname, 'emulators', emu.type + '.js'));
			emulib.start(this.config, emu, opts, function (err, emulator) {
				if (err) {
					callback(err);
				} else {
					checkedBooted(this.config, opts, emulator);
					callback(null, emulator);
				}
			}.bind(this));
		}.bind(this));
	}.bind(this));
};

/**
 * Stops the specified emulator, if running.
 * @param {String} name - The name of the emulator
 * @param {Object} [opts] - Options for detection and killing the emulator
 * @param {Function} callback - A function to call when the emulator as been killed
 */
EmulatorManager.prototype.stop = function stop(name, opts, callback) {
	if (opts && typeof opts == 'function') {
		callback = opts;
		opts = {};
	}

	this.isRunning(name, opts, function (err, running) {
		if (err) {
			// something went boom
			callback(err);
		} else if (!running) {
			// already stopped
			callback(new Error(__('Emulator "%s" not running', name)));
		} else {
			require(path.join(__dirname, 'emulators', running.emulator.type + '.js')).stop(this.config, name, running, opts, callback);
		}
	}.bind(this));
};
